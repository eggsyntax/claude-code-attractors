/**
 * Interactive Code Analysis Report JavaScript
 *
 * This script creates interactive visualizations and handles user interactions
 * for the code analysis report generated by the Rust analyzer.
 */

class CodeAnalysisReport {
    constructor() {
        this.data = window.reportData;
        this.heatmapData = window.heatmapData;
        this.dependencyGraphData = window.dependencyGraphData;
        this.insightsData = window.insightsData;

        this.charts = {};
        this.filters = {
            priority: 'all',
            category: 'all',
            fileSearch: ''
        };

        this.init();
    }

    init() {
        this.setupNavigation();
        this.populateOverview();
        this.createCharts();
        this.createComplexityHeatmap();
        this.createDependencyGraph();
        this.renderInsights();
        this.renderFilesList();
        this.setupEventListeners();
    }

    setupNavigation() {
        const navButtons = document.querySelectorAll('.nav-btn');
        const sections = document.querySelectorAll('.report-section');

        navButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const targetSection = btn.dataset.section;

                // Update active nav button
                navButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                // Update active section
                sections.forEach(s => s.classList.remove('active'));
                document.getElementById(targetSection).classList.add('active');
            });
        });
    }

    populateOverview() {
        const metrics = this.data.summary_metrics;

        document.getElementById('total-files').textContent = metrics.total_files.toLocaleString();
        document.getElementById('total-functions').textContent = metrics.total_functions.toLocaleString();
        document.getElementById('avg-complexity').textContent = metrics.average_complexity.toFixed(1);
        document.getElementById('technical-debt').textContent = metrics.technical_debt_score.toFixed(1) + '/10';

        // Update metric card colors based on values
        this.updateMetricCardColor('technical-debt', metrics.technical_debt_score, [3, 6, 8]);
        this.updateMetricCardColor('avg-complexity', metrics.average_complexity, [5, 10, 15]);
    }

    updateMetricCardColor(elementId, value, thresholds) {
        const element = document.getElementById(elementId);
        const card = element.closest('.metric-card');

        if (value <= thresholds[0]) {
            card.style.borderLeft = '4px solid var(--success-color)';
        } else if (value <= thresholds[1]) {
            card.style.borderLeft = '4px solid var(--warning-color)';
        } else if (value <= thresholds[2]) {
            card.style.borderLeft = '4px solid var(--danger-color)';
        } else {
            card.style.borderLeft = '4px solid var(--critical-color)';
        }
    }

    createCharts() {
        this.createComplexityDistributionChart();
        this.createLanguageDistributionChart();
    }

    createComplexityDistributionChart() {
        const ctx = document.getElementById('complexity-chart').getContext('2d');
        const complexityBuckets = this.calculateComplexityBuckets();

        this.charts.complexity = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: Object.keys(complexityBuckets),
                datasets: [{
                    label: 'Functions',
                    data: Object.values(complexityBuckets),
                    backgroundColor: [
                        'rgba(5, 150, 105, 0.8)',
                        'rgba(217, 119, 6, 0.8)',
                        'rgba(220, 38, 38, 0.8)',
                        'rgba(153, 27, 27, 0.8)'
                    ],
                    borderColor: [
                        'rgba(5, 150, 105, 1)',
                        'rgba(217, 119, 6, 1)',
                        'rgba(220, 38, 38, 1)',
                        'rgba(153, 27, 27, 1)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            title: (items) => `Complexity: ${items[0].label}`,
                            label: (item) => `${item.raw} functions`
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    }
                }
            }
        });
    }

    calculateComplexityBuckets() {
        const buckets = {
            'Low (1-5)': 0,
            'Medium (6-10)': 0,
            'High (11-20)': 0,
            'Critical (21+)': 0
        };

        this.data.file_analysis.forEach(file => {
            file.functions.forEach(func => {
                if (func.complexity <= 5) {
                    buckets['Low (1-5)']++;
                } else if (func.complexity <= 10) {
                    buckets['Medium (6-10)']++;
                } else if (func.complexity <= 20) {
                    buckets['High (11-20)']++;
                } else {
                    buckets['Critical (21+)']++;
                }
            });
        });

        return buckets;
    }

    createLanguageDistributionChart() {
        const ctx = document.getElementById('language-chart').getContext('2d');
        const languageCounts = {};

        this.data.file_analysis.forEach(file => {
            languageCounts[file.language] = (languageCounts[file.language] || 0) + 1;
        });

        const colors = this.generateColors(Object.keys(languageCounts).length);

        this.charts.language = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: Object.keys(languageCounts),
                datasets: [{
                    data: Object.values(languageCounts),
                    backgroundColor: colors,
                    borderWidth: 2,
                    borderColor: '#ffffff'
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: (item) => {
                                const total = Object.values(languageCounts).reduce((a, b) => a + b, 0);
                                const percentage = ((item.raw / total) * 100).toFixed(1);
                                return `${item.label}: ${item.raw} files (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    generateColors(count) {
        const colors = [
            '#3b82f6', '#ef4444', '#10b981', '#f59e0b',
            '#8b5cf6', '#f97316', '#06b6d4', '#84cc16',
            '#ec4899', '#64748b'
        ];
        return colors.slice(0, count);
    }

    createComplexityHeatmap() {
        const container = document.getElementById('complexity-heatmap');
        const data = this.prepareHeatmapData();

        // Create SVG heatmap
        const margin = { top: 20, right: 80, bottom: 60, left: 200 };
        const width = container.clientWidth - margin.left - margin.right;
        const height = Math.max(400, data.length * 25) - margin.top - margin.bottom;

        const svg = d3.select(container)
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom);

        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        // Scales
        const xScale = d3.scaleBand()
            .domain(['Functions', 'Complexity', 'Hotspots', 'LoC'])
            .range([0, width])
            .padding(0.05);

        const yScale = d3.scaleBand()
            .domain(data.map(d => d.file))
            .range([0, height])
            .padding(0.05);

        const maxComplexity = d3.max(data, d => d.complexity);
        const colorScale = d3.scaleSequential(d3.interpolateRdYlBu)
            .domain([maxComplexity, 0]);

        // Create heatmap cells
        const metrics = ['functions', 'complexity', 'hotspots', 'loc'];
        const metricLabels = ['Functions', 'Complexity', 'Hotspots', 'LoC'];

        data.forEach(fileData => {
            metrics.forEach((metric, i) => {
                const normalizedValue = this.normalizeMetricValue(fileData[metric], metric, data);

                g.append('rect')
                    .attr('x', xScale(metricLabels[i]))
                    .attr('y', yScale(fileData.file))
                    .attr('width', xScale.bandwidth())
                    .attr('height', yScale.bandwidth())
                    .attr('fill', colorScale(normalizedValue))
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', 1)
                    .append('title')
                    .text(`${fileData.file}\n${metricLabels[i]}: ${fileData[metric]}`);
            });
        });

        // Add axes
        g.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(xScale));

        g.append('g')
            .call(d3.axisLeft(yScale))
            .selectAll('text')
            .style('font-family', 'Monaco, monospace')
            .style('font-size', '10px');

        // Add color legend
        this.addHeatmapLegend(svg, colorScale, width, height, margin);

        this.setupHeatmapControls();
    }

    prepareHeatmapData() {
        return this.heatmapData.map(item => ({
            file: item.file.split('/').pop(), // Show just filename
            functions: item.functions,
            complexity: item.complexity,
            hotspots: item.hotspots,
            loc: item.loc
        })).sort((a, b) => b.complexity - a.complexity);
    }

    normalizeMetricValue(value, metric, data) {
        const values = data.map(d => d[metric]);
        const min = Math.min(...values);
        const max = Math.max(...values);
        return max === min ? 0 : (value - min) / (max - min) * 100;
    }

    addHeatmapLegend(svg, colorScale, width, height, margin) {
        const legendHeight = 200;
        const legendWidth = 20;

        const legend = svg.append('g')
            .attr('transform', `translate(${width + margin.left + 20}, ${margin.top})`);

        const legendScale = d3.scaleLinear()
            .domain(colorScale.domain())
            .range([legendHeight, 0]);

        const legendAxis = d3.axisRight(legendScale)
            .tickSize(6)
            .ticks(5);

        // Create gradient
        const defs = svg.append('defs');
        const gradient = defs.append('linearGradient')
            .attr('id', 'legend-gradient')
            .attr('x1', '0%')
            .attr('y1', '100%')
            .attr('x2', '0%')
            .attr('y2', '0%');

        gradient.selectAll('stop')
            .data(colorScale.ticks().map((t, i, n) => ({
                offset: `${100 * i / (n.length - 1)}%`,
                color: colorScale(t)
            })))
            .enter().append('stop')
            .attr('offset', d => d.offset)
            .attr('stop-color', d => d.color);

        legend.append('rect')
            .attr('width', legendWidth)
            .attr('height', legendHeight)
            .style('fill', 'url(#legend-gradient)');

        legend.append('g')
            .attr('transform', `translate(${legendWidth}, 0)`)
            .call(legendAxis);

        legend.append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', -10)
            .attr('x', -legendHeight / 2)
            .style('text-anchor', 'middle')
            .style('font-size', '12px')
            .text('Complexity Score');
    }

    setupHeatmapControls() {
        const thresholdSlider = document.getElementById('complexity-threshold');
        const thresholdValue = document.getElementById('threshold-value');

        thresholdSlider.addEventListener('input', (e) => {
            thresholdValue.textContent = e.target.value;
            this.updateComplexityHighlights(parseInt(e.target.value));
        });

        document.getElementById('export-heatmap').addEventListener('click', () => {
            this.exportHeatmapAsPNG();
        });
    }

    updateComplexityHighlights(threshold) {
        // Update heatmap highlighting based on threshold
        const heatmapSvg = d3.select('#complexity-heatmap svg');
        heatmapSvg.selectAll('rect')
            .style('stroke-width', d => {
                // This would need to be properly implemented with data binding
                return 1;
            });
    }

    createDependencyGraph() {
        if (!this.dependencyGraphData.nodes.length) {
            document.getElementById('dependency-graph').innerHTML =
                '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #64748b;">No dependency data available</div>';
            return;
        }

        const container = document.getElementById('dependency-graph');

        // Transform data for vis.js
        const nodes = new vis.DataSet(this.dependencyGraphData.nodes.map(node => ({
            id: node.id,
            label: node.label,
            title: `${node.label}\nType: ${node.module_type}\nComplexity: ${node.complexity_score}`,
            color: this.getNodeColor(node.complexity_score),
            size: Math.max(20, Math.min(50, node.size / 10))
        })));

        const edges = new vis.DataSet(this.dependencyGraphData.edges.map(edge => ({
            from: edge.from,
            to: edge.to,
            title: `Dependency strength: ${edge.strength.toFixed(2)}`,
            width: Math.max(1, edge.strength * 5),
            arrows: 'to'
        })));

        const data = { nodes, edges };
        const options = {
            nodes: {
                shape: 'dot',
                font: {
                    size: 14,
                    color: '#1e293b'
                },
                borderWidth: 2,
                shadow: true
            },
            edges: {
                color: {
                    color: '#64748b',
                    highlight: '#2563eb'
                },
                smooth: {
                    type: 'continuous'
                }
            },
            physics: {
                enabled: true,
                stabilization: { iterations: 150 }
            },
            interaction: {
                hover: true,
                tooltipDelay: 200
            }
        };

        this.dependencyNetwork = new vis.Network(container, data, options);

        this.setupDependencyGraphControls();
    }

    getNodeColor(complexityScore) {
        if (complexityScore < 10) return '#10b981';
        if (complexityScore < 20) return '#f59e0b';
        if (complexityScore < 30) return '#ef4444';
        return '#991b1b';
    }

    setupDependencyGraphControls() {
        document.getElementById('layout-hierarchical').addEventListener('click', () => {
            const options = {
                layout: {
                    hierarchical: {
                        enabled: true,
                        direction: 'UD',
                        sortMethod: 'directed'
                    }
                }
            };
            this.dependencyNetwork.setOptions(options);
        });

        document.getElementById('layout-force').addEventListener('click', () => {
            const options = {
                layout: {
                    hierarchical: {
                        enabled: false
                    }
                }
            };
            this.dependencyNetwork.setOptions(options);
        });

        document.getElementById('export-graph').addEventListener('click', () => {
            this.exportDependencyGraphAsSVG();
        });

        // Show circular dependencies
        this.renderCircularDependencies();
    }

    renderCircularDependencies() {
        const container = document.getElementById('circular-deps-list');
        const cycles = this.dependencyGraphData.circular_dependencies;

        if (cycles.length === 0) {
            container.innerHTML = '<p style="color: #10b981;">âœ… No circular dependencies detected</p>';
            return;
        }

        const cyclesHtml = cycles.map((cycle, index) => `
            <div class="circular-dep-item" style="background: #fef2f2; padding: 1rem; border-radius: 8px; border-left: 4px solid #ef4444; margin-bottom: 0.5rem;">
                <strong>Cycle ${index + 1}:</strong> ${cycle.join(' â†’ ')} â†’ ${cycle[0]}
            </div>
        `).join('');

        container.innerHTML = cyclesHtml;
    }

    renderInsights() {
        this.filteredInsights = [...this.insightsData];
        this.updateInsightsDisplay();
        this.setupInsightsFilters();
    }

    updateInsightsDisplay() {
        const container = document.getElementById('insights-list');

        if (this.filteredInsights.length === 0) {
            container.innerHTML = '<p style="color: #64748b; text-align: center; padding: 2rem;">No insights match the current filters</p>';
            return;
        }

        const insightsHtml = this.filteredInsights.map(insight => `
            <div class="insight-card ${insight.priority.toLowerCase()}">
                <div class="insight-header">
                    <h3 class="insight-title">${insight.title}</h3>
                    <span class="insight-priority ${insight.priority.toLowerCase()}">${insight.priority}</span>
                </div>
                <p class="insight-description">${insight.description}</p>
                <div class="insight-recommendation">
                    <strong>ðŸ’¡ Recommendation:</strong> ${insight.recommendation}
                </div>
                <div class="insight-meta">
                    <div class="affected-files">
                        <strong>Affected files:</strong> ${insight.affected_files.length} file${insight.affected_files.length !== 1 ? 's' : ''}
                    </div>
                    <div class="effort-estimate">${this.formatEffortEstimate(insight.effort_estimate)}</div>
                </div>
            </div>
        `).join('');

        container.innerHTML = insightsHtml;
    }

    formatEffortEstimate(estimate) {
        const estimates = {
            'Small': '< 1 day',
            'Medium': '1-3 days',
            'Large': '1-2 weeks',
            'XLarge': '> 2 weeks'
        };
        return estimates[estimate] || estimate;
    }

    setupInsightsFilters() {
        const priorityFilter = document.getElementById('priority-filter');
        const categoryFilter = document.getElementById('category-filter');

        priorityFilter.addEventListener('change', (e) => {
            this.filters.priority = e.target.value;
            this.applyInsightsFilters();
        });

        categoryFilter.addEventListener('change', (e) => {
            this.filters.category = e.target.value;
            this.applyInsightsFilters();
        });
    }

    applyInsightsFilters() {
        this.filteredInsights = this.insightsData.filter(insight => {
            const matchesPriority = this.filters.priority === 'all' ||
                insight.priority.toLowerCase() === this.filters.priority;

            const matchesCategory = this.filters.category === 'all' ||
                insight.category.toLowerCase().replace('_', '-') === this.filters.category;

            return matchesPriority && matchesCategory;
        });

        this.updateInsightsDisplay();
    }

    renderFilesList() {
        this.filteredFiles = [...this.data.file_analysis];
        this.updateFilesDisplay();
        this.setupFilesControls();
    }

    updateFilesDisplay() {
        const container = document.getElementById('files-list');

        const filesHtml = this.filteredFiles.map(file => `
            <div class="file-card">
                <div class="file-header">
                    <div class="file-path">${file.path}</div>
                    <div class="file-language">${file.language}</div>
                </div>
                <div class="file-metrics">
                    <div class="file-metric">
                        <div class="file-metric-value">${file.complexity_score}</div>
                        <div class="file-metric-label">Complexity</div>
                    </div>
                    <div class="file-metric">
                        <div class="file-metric-value">${file.function_count}</div>
                        <div class="file-metric-label">Functions</div>
                    </div>
                    <div class="file-metric">
                        <div class="file-metric-value">${file.lines_of_code}</div>
                        <div class="file-metric-label">Lines</div>
                    </div>
                    <div class="file-metric">
                        <div class="file-metric-value">${file.complexity_hotspots.length}</div>
                        <div class="file-metric-label">Hotspots</div>
                    </div>
                </div>
                ${file.functions.length > 0 ? this.renderFunctionsList(file.functions) : ''}
            </div>
        `).join('');

        container.innerHTML = filesHtml;
    }

    renderFunctionsList(functions) {
        if (functions.length === 0) return '';

        const functionsHtml = functions
            .sort((a, b) => b.complexity - a.complexity)
            .slice(0, 10) // Show top 10 most complex functions
            .map(func => `
                <div class="function-item">
                    <span class="function-name">${func.name}</span>
                    <span class="function-complexity ${this.getComplexityClass(func.complexity)}">${func.complexity}</span>
                </div>
            `).join('');

        return `
            <div class="functions-list">
                <h4>Top Functions by Complexity</h4>
                ${functionsHtml}
            </div>
        `;
    }

    getComplexityClass(complexity) {
        if (complexity <= 5) return 'low';
        if (complexity <= 10) return 'medium';
        if (complexity <= 20) return 'high';
        return 'critical';
    }

    setupFilesControls() {
        const searchInput = document.getElementById('file-search');
        const sortSelect = document.getElementById('sort-files');

        searchInput.addEventListener('input', (e) => {
            this.filters.fileSearch = e.target.value.toLowerCase();
            this.applyFilesFilters();
        });

        sortSelect.addEventListener('change', (e) => {
            this.sortFiles(e.target.value);
        });
    }

    applyFilesFilters() {
        this.filteredFiles = this.data.file_analysis.filter(file => {
            return file.path.toLowerCase().includes(this.filters.fileSearch);
        });

        this.updateFilesDisplay();
    }

    sortFiles(sortBy) {
        this.filteredFiles.sort((a, b) => {
            switch (sortBy) {
                case 'complexity':
                    return b.complexity_score - a.complexity_score;
                case 'name':
                    return a.path.localeCompare(b.path);
                case 'size':
                    return b.lines_of_code - a.lines_of_code;
                default:
                    return 0;
            }
        });

        this.updateFilesDisplay();
    }

    setupEventListeners() {
        // Add any additional event listeners here
        window.addEventListener('resize', () => {
            Object.values(this.charts).forEach(chart => {
                if (chart && typeof chart.resize === 'function') {
                    chart.resize();
                }
            });
        });
    }

    exportHeatmapAsPNG() {
        const svg = document.querySelector('#complexity-heatmap svg');
        if (!svg) return;

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const data = new XMLSerializer().serializeToString(svg);
        const img = new Image();
        const svgBlob = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);

        img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            URL.revokeObjectURL(url);

            canvas.toBlob((blob) => {
                const link = document.createElement('a');
                link.download = 'complexity-heatmap.png';
                link.href = URL.createObjectURL(blob);
                link.click();
            });
        };

        img.src = url;
    }

    exportDependencyGraphAsSVG() {
        // This would require access to vis.js internals
        // For now, we'll show a notification
        alert('SVG export functionality would be implemented here');
    }
}

// Initialize the report when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new CodeAnalysisReport();
});

// Add some utility functions for data processing
const Utils = {
    formatFileSize(bytes) {
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        if (bytes === 0) return '0 Bytes';
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
    },

    formatDuration(seconds) {
        if (seconds < 60) return `${seconds}s`;
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;
        return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
    },

    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
};