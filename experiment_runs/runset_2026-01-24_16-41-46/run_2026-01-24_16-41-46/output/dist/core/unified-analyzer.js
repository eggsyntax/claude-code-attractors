"use strict";
/**
 * Unified Analysis Orchestrator
 * Coordinates Alice's structural analysis with Bob's architectural analysis
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnifiedAnalyzer = void 0;
const structural_analyzer_js_1 = require("../alice/structural-analyzer.js");
const architectural_analyzer_js_1 = require("../bob/architectural-analyzer.js");
class UnifiedAnalyzer {
    constructor() {
        this.aliceAnalyzer = new structural_analyzer_js_1.StructuralAnalyzer();
        this.bobAnalyzer = new architectural_analyzer_js_1.ArchitecturalAnalyzer();
    }
    async analyzeProject(projectPath) {
        console.log('ðŸš€ Starting unified code analysis...');
        const timestamp = new Date().toISOString();
        // Run both analyses in parallel for efficiency
        console.log('âš¡ Running parallel analysis...');
        const [structuralResults, architecturalResults] = await Promise.all([
            this.aliceAnalyzer.analyzeProject(projectPath),
            this.bobAnalyzer.analyzeProject(projectPath)
        ]);
        console.log('ðŸ”— Generating cross-references...');
        // Generate cross-references between the analyses
        const crossReferences = this.generateCrossReferences(structuralResults, architecturalResults);
        console.log('ðŸ“‹ Generating unified summary...');
        // Create unified summary
        const summary = this.generateUnifiedSummary(structuralResults, architecturalResults, crossReferences);
        return {
            timestamp,
            projectPath,
            structural: [structuralResults],
            architectural: [architecturalResults],
            crossReferences,
            summary
        };
    }
    generateCrossReferences(structural, // StructuralAnalysis
    architectural // ArchitecturalAnalysis
    ) {
        const crossReferences = [];
        // Use Alice's cross-reference generation method
        const aliceCrossRefs = this.aliceAnalyzer.generateArchitecturalCrossReferences(structural, architectural.patterns || []);
        // Convert to our CrossReference format
        crossReferences.push(...aliceCrossRefs.map(ref => ({
            structuralFinding: ref.structuralFinding,
            architecturalFinding: ref.architecturalFinding,
            relationship: ref.relationship,
            insight: ref.insight
        })));
        // Add Bob's perspective (architectural -> structural insights)
        // These would be generated by Bob's analyzer looking at Alice's findings
        // Example: High coupling classes might indicate architectural pattern violations
        for (const cls of structural.classes || []) {
            if (cls.coupling > 0.8) {
                crossReferences.push({
                    structuralFinding: `High coupling in class ${cls.name} (${Math.round(cls.coupling * 100)}%)`,
                    architecturalFinding: 'Potential violation of architectural boundaries',
                    relationship: 'explains',
                    insight: 'High coupling suggests the class may be violating single responsibility or architectural layer boundaries'
                });
            }
        }
        return crossReferences;
    }
    generateUnifiedSummary(structural, architectural, crossReferences) {
        const keyFindings = [];
        const recommendations = [];
        const collaborationNotes = [];
        // Key findings from Alice's analysis
        if (structural.complexity?.hotspots?.length > 0) {
            keyFindings.push(`ðŸ”¥ ${structural.complexity.hotspots.length} complexity hotspots identified`);
        }
        if (structural.dependencies?.filter((d) => d.isCircular).length > 0) {
            const circularCount = structural.dependencies.filter((d) => d.isCircular).length;
            keyFindings.push(`ðŸ”„ ${circularCount} circular dependencies detected`);
        }
        // Key findings from Bob's analysis
        if (architectural.patterns?.length > 0) {
            keyFindings.push(`ðŸ—ï¸ ${architectural.patterns.length} architectural patterns identified`);
        }
        // Cross-reference insights
        const conflictingRefs = crossReferences.filter(ref => ref.relationship === 'conflicts');
        if (conflictingRefs.length > 0) {
            keyFindings.push(`âš ï¸ ${conflictingRefs.length} structural-architectural conflicts found`);
        }
        // Recommendations based on combined analysis
        if (structural.reusability?.duplicateCode?.filter((d) => d.severity === 'high').length > 0) {
            recommendations.push('Consider extracting common patterns into reusable architectural components');
        }
        if (structural.complexity?.overall > 15) {
            recommendations.push('High overall complexity suggests need for architectural refactoring and pattern application');
        }
        // Collaboration notes
        collaborationNotes.push('Alice focused on micro-level code structure and dependencies');
        collaborationNotes.push('Bob focused on macro-level architectural patterns and design');
        collaborationNotes.push(`Generated ${crossReferences.length} cross-references between analyses`);
        const aliceInsights = this.aliceAnalyzer.generateCollaborativeInsights(structural);
        if (aliceInsights.length > 0) {
            collaborationNotes.push('Alice\'s insights for Bob:');
            collaborationNotes.push(...aliceInsights);
        }
        return {
            keyFindings,
            recommendations,
            collaborationNotes
        };
    }
    // Export method for generating comprehensive reports
    generateReport(analysis) {
        const report = [];
        report.push('# ðŸ” CodeMirror: Unified Code Analysis Report');
        report.push(`**Generated:** ${analysis.timestamp}`);
        report.push(`**Project:** ${analysis.projectPath}`);
        report.push('');
        report.push('## ðŸ“Š Key Findings');
        analysis.summary.keyFindings.forEach(finding => {
            report.push(`- ${finding}`);
        });
        report.push('');
        report.push('## ðŸŽ¯ Recommendations');
        analysis.summary.recommendations.forEach(rec => {
            report.push(`- ${rec}`);
        });
        report.push('');
        report.push('## ðŸ”— Cross-Reference Insights');
        analysis.crossReferences.forEach(ref => {
            report.push(`**${ref.relationship.toUpperCase()}**: ${ref.insight}`);
            report.push(`- Structural: ${ref.structuralFinding}`);
            report.push(`- Architectural: ${ref.architecturalFinding}`);
            report.push('');
        });
        report.push('## ðŸ¤ Collaboration Notes');
        analysis.summary.collaborationNotes.forEach(note => {
            report.push(`- ${note}`);
        });
        return report.join('\n');
    }
}
exports.UnifiedAnalyzer = UnifiedAnalyzer;
