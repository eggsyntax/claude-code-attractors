<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Collaboration Simulator</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff88;
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .main-canvas {
            background: #111;
            border: 2px solid #00ff88;
            border-radius: 8px;
            position: relative;
            height: 500px;
        }

        .agent-panel {
            background: #111;
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 15px;
        }

        .agent {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #00aa66;
            border-radius: 4px;
            background: #0a1a0a;
        }

        .agent.active {
            background: #0a2a0a;
            border-color: #00ff88;
        }

        .agent-name {
            font-weight: bold;
            color: #00ffaa;
        }

        .agent-status {
            font-size: 0.8em;
            color: #88ffaa;
            margin-top: 5px;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        button {
            background: #003322;
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }

        button:hover {
            background: #004433;
        }

        .meta-layer {
            background: #111;
            border: 2px solid #ffaa00;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .meta-title {
            color: #ffaa00;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .collaboration-log {
            height: 200px;
            overflow-y: auto;
            background: #0a0a0a;
            border: 1px solid #666;
            padding: 10px;
            font-size: 0.8em;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-analyzer { color: #88aaff; }
        .log-synthesizer { color: #ff88aa; }
        .log-explorer { color: #aaff88; }
        .log-validator { color: #ffaa88; }
        .log-emergence { color: #ffff00; font-weight: bold; }

        .analytics-dashboard {
            background: #111;
            border: 2px solid #00aaff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .agent-analytics {
            background: #0a0a0a;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 12px;
        }

        .agent-analytics h4 {
            margin: 0 0 10px 0;
            font-size: 0.9em;
            text-transform: uppercase;
        }

        #analyzerAnalytics h4 { color: #88aaff; }
        #synthesizerAnalytics h4 { color: #ff88aa; }
        #explorerAnalytics h4 { color: #aaff88; }
        #validatorAnalytics h4 { color: #ffaa88; }

        .metric {
            font-size: 0.8em;
            margin: 5px 0;
            color: #cccccc;
        }

        .behavior-gauge {
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 8px;
            position: relative;
            overflow: hidden;
        }

        .behavior-gauge::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: var(--gauge-width, 0%);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        #analyzerGauge::after { background: #88aaff; }
        #synthesizerGauge::after { background: #ff88aa; }
        #explorerGauge::after { background: #aaff88; }
        #validatorGauge::after { background: #ffaa88; }

        .challenge-designer {
            background: #111;
            border: 2px solid #ff6600;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }

        .designer-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.9em;
            color: #ff6600;
            font-weight: bold;
        }

        .control-group select, .control-group input {
            background: #222;
            border: 1px solid #666;
            color: #fff;
            padding: 5px;
            border-radius: 3px;
        }

        .control-group button {
            background: #ff4400;
            border: 1px solid #ff6600;
            margin-top: 5px;
        }

        .control-group button:hover {
            background: #ff6600;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Interactive Collaboration Simulator</h1>
            <p>Exploring emergence through AI collaboration patterns</p>
            <p><em>Created by Alice & Bob - Two Claude Code instances exploring collaboration</em></p>
        </div>

        <div class="controls">
            <button onclick="startSimulation()">Start Simulation</button>
            <button onclick="pauseSimulation()">Pause</button>
            <button onclick="resetSimulation()">Reset</button>
            <button onclick="changeChallenge()">New Challenge</button>
            <button onclick="toggleChallengeDesigner()">Design Challenge</button>
        </div>

        <div class="challenge-designer" id="challengeDesigner" style="display: none;">
            <div class="meta-title">Interactive Challenge Designer</div>
            <div class="designer-controls">
                <div class="control-group">
                    <label>Challenge Type:</label>
                    <select id="challengeTypeSelect">
                        <option value="pathfinding">Pathfinding</option>
                        <option value="optimization">Optimization</option>
                        <option value="pattern-recognition">Pattern Recognition</option>
                        <option value="creative-synthesis">Creative Synthesis</option>
                        <option value="multi-objective">Multi-Objective</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Difficulty:</label>
                    <input type="range" id="difficultySlider" min="1" max="5" value="3">
                    <span id="difficultyValue">3</span>
                </div>
                <div class="control-group">
                    <label>Collaboration Requirement:</label>
                    <select id="collaborationSelect">
                        <option value="optional">Optional</option>
                        <option value="recommended">Recommended</option>
                        <option value="required">Required</option>
                        <option value="specialized">Specialized Roles</option>
                    </select>
                </div>
                <div class="control-group">
                    <button onclick="generateChallenge()">Generate Challenge</button>
                    <button onclick="addObstacle()">Add Obstacle</button>
                    <button onclick="clearObstacles()">Clear Obstacles</button>
                </div>
            </div>
        </div>

        <div class="simulation-area">
            <div class="main-canvas" id="mainCanvas">
                <canvas id="simulationCanvas" width="800" height="500"></canvas>
            </div>

            <div class="agent-panel">
                <h3>Active Agents</h3>

                <div class="agent" id="analyzer">
                    <div class="agent-name">The Analyzer</div>
                    <div class="agent-status">Methodical â€¢ Pattern-seeking</div>
                </div>

                <div class="agent" id="synthesizer">
                    <div class="agent-name">The Synthesizer</div>
                    <div class="agent-status">Connection-making â€¢ Integrative</div>
                </div>

                <div class="agent" id="explorer">
                    <div class="agent-name">The Explorer</div>
                    <div class="agent-status">Creative â€¢ Unconventional</div>
                </div>

                <div class="agent" id="validator">
                    <div class="agent-name">The Validator</div>
                    <div class="agent-status">Verification â€¢ Refinement</div>
                </div>
            </div>
        </div>

        <div class="meta-layer">
            <div class="meta-title">Meta-Reflection Layer</div>
            <div class="collaboration-log" id="collaborationLog">
                <div class="log-entry">System initialized. Awaiting simulation start...</div>
            </div>
        </div>

        <div class="analytics-dashboard">
            <div class="meta-title">Real-Time Behavioral Analytics</div>

            <!-- Learning Dashboard -->
            <div class="learning-dashboard" style="grid-column: span 4; margin-bottom: 20px; background: linear-gradient(135deg, #2a1810, #3d2817); border-radius: 8px; padding: 15px;">
                <h3 style="margin: 0 0 10px 0; color: #ff6b35;">ðŸ§  Learning Engine Status</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                    <div class="learning-metric">
                        <div style="color: #888; font-size: 0.8em;">Successful Patterns</div>
                        <div style="font-size: 1.4em; color: #4CAF50;" id="learnedPatterns">0</div>
                    </div>
                    <div class="learning-metric">
                        <div style="color: #888; font-size: 0.8em;">Adaptations Applied</div>
                        <div style="font-size: 1.4em; color: #2196F3;" id="adaptationCount">0</div>
                    </div>
                    <div class="learning-metric">
                        <div style="color: #888; font-size: 0.8em;">Pattern Diversity</div>
                        <div style="font-size: 1.4em; color: #FF9800;" id="patternDiversity">0.0</div>
                    </div>
                </div>
                <div class="recent-learnings" style="margin-top: 10px;">
                    <div style="color: #888; font-size: 0.8em; margin-bottom: 5px;">Recent Learning Events:</div>
                    <div id="learningEvents" style="max-height: 60px; overflow-y: auto; font-size: 0.8em; color: #ddd;">
                        <div class="learning-event">System initialized. Learning in progress...</div>
                    </div>
                </div>
            </div>

            <div class="analytics-grid">
                <div class="agent-analytics" id="analyzerAnalytics">
                    <h4>Analyzer Metrics</h4>
                    <div class="metric">Memory Entries: <span id="analyzerMemory">0</span></div>
                    <div class="metric">Scan Radius: <span id="analyzerRadius">50</span></div>
                    <div class="metric">Coverage: <span id="analyzerCoverage">0%</span></div>
                    <div class="behavior-gauge" id="analyzerGauge"></div>
                </div>

                <div class="agent-analytics" id="synthesizerAnalytics">
                    <h4>Synthesizer Metrics</h4>
                    <div class="metric">Collaboration Score: <span id="synthesizerScore">0</span></div>
                    <div class="metric">Active Connections: <span id="synthesizerConnections">0</span></div>
                    <div class="metric">Integration Index: <span id="synthesizerIntegration">0.0</span></div>
                    <div class="behavior-gauge" id="synthesizerGauge"></div>
                </div>

                <div class="agent-analytics" id="explorerAnalytics">
                    <h4>Explorer Metrics</h4>
                    <div class="metric">Novelty Score: <span id="explorerNovelty">0.0</span></div>
                    <div class="metric">Creativity Boost: <span id="explorerCreativity">0</span></div>
                    <div class="metric">Attempts Made: <span id="explorerAttempts">0</span></div>
                    <div class="behavior-gauge" id="explorerGauge"></div>
                </div>

                <div class="agent-analytics" id="validatorAnalytics">
                    <h4>Validator Metrics</h4>
                    <div class="metric">Confidence Level: <span id="validatorConfidence">50%</span></div>
                    <div class="metric">Errors Detected: <span id="validatorErrors">0</span></div>
                    <div class="metric">Validation Accuracy: <span id="validatorAccuracy">100%</span></div>
                    <div class="behavior-gauge" id="validatorGauge"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Core simulation state
        let simulationRunning = false;
        let currentChallenge = 'pathfinding';
        let challengeTarget = { x: 600, y: 300 };
        let obstacles = [
            { x: 300, y: 200, width: 50, height: 100 },
            { x: 500, y: 150, width: 80, height: 60 },
            { x: 450, y: 350, width: 60, height: 80 }
        ];
        let agents = {
            analyzer: {
                x: 100, y: 100, active: false, approach: 'methodical',
                memory: [], path: [], currentTarget: null,
                behaviorState: 'scanning', scanRadius: 50
            },
            synthesizer: {
                x: 200, y: 150, active: false, approach: 'integrative',
                memory: [], connections: [], insights: [],
                behaviorState: 'observing', collaborationScore: 0
            },
            explorer: {
                x: 300, y: 200, active: false, approach: 'creative',
                memory: [], attempts: [], noveltyScore: 0,
                behaviorState: 'wandering', creativityBoost: 0
            },
            validator: {
                x: 400, y: 120, active: false, approach: 'verification',
                memory: [], validations: [], errorCount: 0,
                behaviorState: 'monitoring', confidence: 0.5
            }
        };

        // Advanced Learning Engine with Meta-Reflection
        let learningEngine = {
            successfulPatterns: new Map(),
            behavioralAdaptations: new Map(),
            emergenceMemory: [],
            adaptationCounter: 0,
            learningRate: 0.1,
            learningHistory: [],
            emergenceEvents: [],

            // Track what combinations lead to successful emergence
            recordSuccess: function(agents, context) {
                const pattern = this.extractPattern(agents, context);
                const key = JSON.stringify(pattern);

                if (!this.successfulPatterns.has(key)) {
                    this.successfulPatterns.set(key, { count: 0, contexts: [], timestamp: Date.now() });
                }

                const record = this.successfulPatterns.get(key);
                record.count++;
                record.contexts.push(context);

                this.emergenceEvents.push({ pattern, context, timestamp: Date.now() });

                logEntry(`ðŸ§  Learning: Pattern recorded (${record.count} times seen)`, 'learning');
            },

            // Extract behavioral pattern from current agent states
            extractPattern: function(agents, context) {
                return {
                    analyzer_systematic: agents.analyzer.behaviorState === 'scanning',
                    synthesizer_connecting: agents.synthesizer.collaborationScore > 30,
                    explorer_creative: agents.explorer.noveltyScore > 0.5,
                    validator_confident: agents.validator.confidence > 0.6,
                    proximity_clusters: this.detectClusters(agents),
                    context_type: typeof context === 'string' ? context : context.type
                };
            },

            // Adapt agent behaviors based on learned successful patterns
            adaptBehaviors: function(agents) {
                if (this.successfulPatterns.size === 0) return;

                this.adaptationCounter++;
                const currentPattern = this.extractPattern(agents, currentChallenge);
                const similarSuccesses = this.findSimilarPatterns(currentPattern);

                if (similarSuccesses.length > 0) {
                    this.applyAdaptations(agents, similarSuccesses);
                    logEntry(`ðŸ”„ Adaptation #${this.adaptationCounter}: Behaviors evolved`, 'adaptation');
                }
            },

            findSimilarPatterns: function(current) {
                const similar = [];
                for (let [patternKey, record] of this.successfulPatterns) {
                    const pattern = JSON.parse(patternKey);
                    const similarity = this.calculateSimilarity(pattern, current);
                    if (similarity > 0.6 && record.count > 1) {
                        similar.push({ pattern, record, similarity });
                    }
                }
                return similar.sort((a, b) => b.similarity - a.similarity).slice(0, 3);
            },

            calculateSimilarity: function(p1, p2) {
                let matches = 0;
                let total = 0;
                for (let key in p1) {
                    if (key in p2) {
                        total++;
                        if (p1[key] === p2[key]) matches++;
                    }
                }
                return total > 0 ? matches / total : 0;
            },

            detectClusters: function(agents) {
                const agentsList = Object.values(agents);
                let clusters = 0;

                for (let i = 0; i < agentsList.length; i++) {
                    for (let j = i + 1; j < agentsList.length; j++) {
                        const dist = Math.sqrt(
                            Math.pow(agentsList[i].x - agentsList[j].x, 2) +
                            Math.pow(agentsList[i].y - agentsList[j].y, 2)
                        );
                        if (dist < 80) clusters++;
                    }
                }
                return clusters;
            },

            applyAdaptations: function(agents, successfulPatterns) {
                const bestPattern = successfulPatterns[0].pattern;

                // Evolve analyzer behavior
                if (bestPattern.analyzer_systematic) {
                    agents.analyzer.scanRadius = Math.min(agents.analyzer.scanRadius * 1.05, 100);
                }

                // Evolve synthesizer connections
                if (bestPattern.synthesizer_connecting) {
                    agents.synthesizer.connectionRadius = 120; // Enhanced connection seeking
                }

                // Evolve explorer creativity
                if (bestPattern.explorer_creative) {
                    agents.explorer.creativityBoost = Math.min(agents.explorer.creativityBoost + 0.1, 1.5);
                }

                // Evolve validator confidence
                if (bestPattern.validator_confident) {
                    agents.validator.validationThreshold = Math.max(agents.validator.validationThreshold * 0.98, 0.3);
                }
            },

            // Meta-Learning: System reflects on its own learning process
            performMetaReflection: function() {
                const reflectionData = {
                    totalPatterns: this.successfulPatterns.size,
                    recentAdaptations: this.adaptationCounter,
                    diversityTrend: this.calculateDiversityTrend(),
                    emergenceFrequency: this.calculateEmergenceFrequency(),
                    timestamp: Date.now()
                };

                // Generate insights about the learning process itself
                const insights = this.generateMetaInsights(reflectionData);

                if (insights.length > 0) {
                    logEntry(`ðŸ§  META-INSIGHT: ${insights[0]}`, 'meta-learning');
                    this.updateLearningHistory(reflectionData);
                }
            },

            calculateDiversityTrend: function() {
                if (this.learningHistory.length < 2) return 'stable';

                const recent = this.learningHistory.slice(-3);
                const diversityScores = recent.map(h => h.patternTypes.size);

                if (diversityScores[diversityScores.length - 1] > diversityScores[0]) return 'increasing';
                if (diversityScores[diversityScores.length - 1] < diversityScores[0]) return 'decreasing';
                return 'stable';
            },

            calculateEmergenceFrequency: function() {
                const recentEmergences = this.emergenceEvents.filter(e =>
                    Date.now() - e.timestamp < 10000 // last 10 seconds
                );
                return recentEmergences.length;
            },

            generateMetaInsights: function(data) {
                const insights = [];

                if (data.diversityTrend === 'increasing' && data.emergenceFrequency > 2) {
                    insights.push("System entering creative explosion phase - rapid discovery of novel patterns");
                }

                if (data.recentAdaptations > 5 && data.emergenceFrequency < 1) {
                    insights.push("Over-adaptation detected - system may be losing exploratory capacity");
                }

                if (data.totalPatterns > 10 && data.diversityTrend === 'stable') {
                    insights.push("Wisdom consolidation phase - system has found stable collaborative equilibrium");
                }

                if (data.emergenceFrequency > 3 && this.successfulPatterns.size < 3) {
                    insights.push("High emergence with low retention - system discovering but not learning");
                }

                return insights;
            },

            updateLearningHistory: function(data) {
                this.learningHistory.push({
                    ...data,
                    patternTypes: new Set(Array.from(this.successfulPatterns.values()).map(p =>
                        p.contexts.length > 0 ? p.contexts[0].type : 'unknown'
                    ))
                });

                // Keep only recent history
                if (this.learningHistory.length > 20) {
                    this.learningHistory = this.learningHistory.slice(-20);
                }
            }
        };

        // Canvas setup
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        // Logging function
        function logEntry(message, type = 'system') {
            const log = document.getElementById('collaborationLog');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // Simulation control functions
        function startSimulation() {
            simulationRunning = true;
            logEntry('Simulation started - agents beginning collaboration', 'system');

            // Activate agents in sequence with different strategies
            setTimeout(() => activateAgent('analyzer'), 1000);
            setTimeout(() => activateAgent('explorer'), 2000);
            setTimeout(() => activateAgent('synthesizer'), 3000);
            setTimeout(() => activateAgent('validator'), 4000);

            simulationLoop();
        }

        function pauseSimulation() {
            simulationRunning = false;
            logEntry('Simulation paused', 'system');
        }

        function resetSimulation() {
            simulationRunning = false;
            Object.keys(agents).forEach(key => {
                agents[key].active = false;
                document.getElementById(key).classList.remove('active');
            });
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('collaborationLog').innerHTML =
                '<div class="log-entry">System reset. Ready for new simulation...</div>';
        }

        function changeChallenge() {
            const challenges = ['pathfinding', 'optimization', 'pattern-recognition', 'creative-synthesis'];
            const currentIndex = challenges.indexOf(currentChallenge);
            currentChallenge = challenges[(currentIndex + 1) % challenges.length];
            logEntry(`Challenge changed to: ${currentChallenge}`, 'system');
        }

        function activateAgent(agentType) {
            agents[agentType].active = true;
            document.getElementById(agentType).classList.add('active');

            const agentMessages = {
                analyzer: 'Beginning systematic analysis of the problem space',
                synthesizer: 'Looking for patterns and connections between elements',
                explorer: 'Trying unconventional approaches and creative solutions',
                validator: 'Checking assumptions and validating proposed solutions'
            };

            logEntry(agentMessages[agentType], agentType);
        }

        // Main simulation loop
        function simulationLoop() {
            if (!simulationRunning) return;

            // Clear canvas
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw challenge environment
            drawChallenge();

            // Update agent behaviors
            Object.keys(agents).forEach(agentType => {
                const agent = agents[agentType];
                if (agent.active) {
                    updateAgentBehavior(agent, agentType);
                }
            });

            // Draw active agents
            Object.keys(agents).forEach((key, index) => {
                const agent = agents[key];
                if (agent.active) {
                    drawAgent(agent, index, key);
                }
            });

            // Simulate collaboration interactions and detect emergence
            simulateCollaboration();
            detectEmergence();

            // Update analytics dashboard
            updateAnalyticsDashboard();
            updateLearningDashboard();

            // Continue loop
            setTimeout(simulationLoop, 150);
        }

        function drawAgent(agent, index, type) {
            const colors = {
                analyzer: '#88aaff',
                synthesizer: '#ff88aa',
                explorer: '#aaff88',
                validator: '#ffaa88'
            };

            // Draw agent-specific visual patterns based on their behavior
            ctx.fillStyle = colors[type];
            let visualX = agent.x;
            let visualY = agent.y;

            // Each agent type has distinct movement patterns
            switch(type) {
                case 'analyzer':
                    // Systematic grid-like scanning pattern
                    visualX += Math.floor(Date.now() * 0.002) % 40 - 20;
                    break;
                case 'synthesizer':
                    // Gentle orbiting pattern connecting to others
                    visualX += Math.sin(Date.now() * 0.0015 + index) * 15;
                    visualY += Math.cos(Date.now() * 0.0015 + index) * 15;
                    break;
                case 'explorer':
                    // Chaotic, creative movement with sudden direction changes
                    visualX += Math.sin(Date.now() * 0.003 + agent.noveltyScore) * 25;
                    visualY += Math.cos(Date.now() * 0.004 + agent.noveltyScore) * 25;
                    break;
                case 'validator':
                    // Steady, cautious movement with validation checks
                    visualX += Math.sin(Date.now() * 0.001 + index) * 8;
                    visualY += Math.cos(Date.now() * 0.0008 + index) * 8;
                    break;
            }

            // Draw agent
            ctx.beginPath();
            ctx.arc(visualX, visualY, 8, 0, 2 * Math.PI);
            ctx.fill();

            // Draw behavior-specific indicators
            ctx.strokeStyle = colors[type];
            ctx.lineWidth = 1;
            if (type === 'analyzer' && agent.behaviorState === 'scanning') {
                // Draw scanning radius
                ctx.beginPath();
                ctx.arc(visualX, visualY, agent.scanRadius, 0, 2 * Math.PI);
                ctx.stroke();
            }

            // Draw connections for synthesis moments
            if (type === 'synthesizer' && agent.connections.length > 0) {
                agent.connections.forEach(conn => {
                    if (agents[conn] && agents[conn].active) {
                        ctx.strokeStyle = colors[type];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(visualX, visualY);
                        ctx.lineTo(agents[conn].x, agents[conn].y);
                        ctx.stroke();
                    }
                });
            }
        }

        // Draw challenge environment
        function drawChallenge() {
            // Draw target
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(challengeTarget.x, challengeTarget.y, 15, 0, 2 * Math.PI);
            ctx.fill();

            // Draw obstacles
            ctx.fillStyle = '#ff4444';
            obstacles.forEach(obstacle => {
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });

            // Draw challenge label
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Courier New';
            ctx.fillText(`Challenge: ${currentChallenge}`, 10, 25);
        }

        // Individual agent behavior algorithms
        function updateAgentBehavior(agent, type) {
            switch(type) {
                case 'analyzer':
                    analyzerBehavior(agent);
                    break;
                case 'synthesizer':
                    synthesizerBehavior(agent);
                    break;
                case 'explorer':
                    explorerBehavior(agent);
                    break;
                case 'validator':
                    validatorBehavior(agent);
                    break;
            }
        }

        function analyzerBehavior(agent) {
            // Systematic, methodical approach
            switch(agent.behaviorState) {
                case 'scanning':
                    // Grid-based systematic scanning
                    agent.memory.push({
                        x: agent.x, y: agent.y,
                        obstacles: obstacles.filter(obs =>
                            Math.abs(obs.x - agent.x) < agent.scanRadius &&
                            Math.abs(obs.y - agent.y) < agent.scanRadius
                        ),
                        timestamp: Date.now()
                    });

                    // Move in systematic pattern
                    if (agent.memory.length % 20 === 0) {
                        agent.x = Math.min(agent.x + 40, canvas.width - 50);
                        if (agent.x >= canvas.width - 50) {
                            agent.x = 50;
                            agent.y = Math.min(agent.y + 60, canvas.height - 50);
                        }
                    }
                    break;
            }
        }

        function synthesizerBehavior(agent) {
            // Integration and connection-making
            // Look for patterns in other agents' behaviors
            const activeAgents = Object.keys(agents).filter(k => agents[k].active && k !== 'synthesizer');

            activeAgents.forEach(agentType => {
                const otherAgent = agents[agentType];
                const distance = Math.sqrt(
                    Math.pow(agent.x - otherAgent.x, 2) +
                    Math.pow(agent.y - otherAgent.y, 2)
                );

                if (distance < 100 && !agent.connections.includes(agentType)) {
                    agent.connections.push(agentType);
                    agent.collaborationScore++;
                    logEntry(`Synthesizer connecting insights from ${agentType}`, 'synthesizer');
                }
            });

            // Move toward center of active agents for better synthesis
            if (activeAgents.length > 0) {
                const avgX = activeAgents.reduce((sum, k) => sum + agents[k].x, 0) / activeAgents.length;
                const avgY = activeAgents.reduce((sum, k) => sum + agents[k].y, 0) / activeAgents.length;

                agent.x += (avgX - agent.x) * 0.02;
                agent.y += (avgY - agent.y) * 0.02;
            }
        }

        function explorerBehavior(agent) {
            // Creative, unconventional approaches
            switch(agent.behaviorState) {
                case 'wandering':
                    // Random exploration with increasing novelty
                    if (Math.random() < 0.3) {
                        const novelDirection = agent.noveltyScore * Math.PI / 4;
                        agent.x += Math.cos(novelDirection) * 15;
                        agent.y += Math.sin(novelDirection) * 15;
                        agent.noveltyScore += 0.1;

                        // Try unconventional paths
                        agent.attempts.push({ x: agent.x, y: agent.y, novelty: agent.noveltyScore });
                    }

                    // Boundary checking with creative rebounds
                    if (agent.x < 0 || agent.x > canvas.width) {
                        agent.x = Math.max(0, Math.min(agent.x, canvas.width));
                        agent.noveltyScore += 0.5; // Boost creativity from constraint
                    }
                    if (agent.y < 0 || agent.y > canvas.height) {
                        agent.y = Math.max(0, Math.min(agent.y, canvas.height));
                        agent.noveltyScore += 0.5;
                    }
                    break;
            }
        }

        function validatorBehavior(agent) {
            // Verification and refinement
            // Check other agents' approaches for validity
            Object.keys(agents).forEach(agentType => {
                if (agentType !== 'validator' && agents[agentType].active) {
                    const otherAgent = agents[agentType];

                    // Validate if other agent is moving toward obstacles
                    obstacles.forEach(obstacle => {
                        const distToObstacle = Math.sqrt(
                            Math.pow(otherAgent.x - obstacle.x, 2) +
                            Math.pow(otherAgent.y - obstacle.y, 2)
                        );

                        if (distToObstacle < 80) {
                            agent.errorCount++;
                            agent.confidence *= 0.95; // Reduce confidence when errors found
                            logEntry(`Validator detected potential collision risk for ${agentType}`, 'validator');
                        }
                    });
                }
            });

            // Move to strategic monitoring positions
            agent.x += (canvas.width/2 - agent.x) * 0.01;
            agent.y += (canvas.height/2 - agent.y) * 0.01;
        }

        function simulateCollaboration() {
            // Enhanced collaboration based on agent behaviors and proximity
            const activeAgents = Object.keys(agents).filter(key => agents[key].active);

            activeAgents.forEach(agent1Type => {
                activeAgents.forEach(agent2Type => {
                    if (agent1Type !== agent2Type) {
                        const agent1 = agents[agent1Type];
                        const agent2 = agents[agent2Type];
                        const distance = Math.sqrt(
                            Math.pow(agent1.x - agent2.x, 2) +
                            Math.pow(agent1.y - agent2.y, 2)
                        );

                        // Close proximity enables specific collaborations
                        if (distance < 80 && Math.random() < 0.08) {
                            handleSpecificCollaboration(agent1Type, agent2Type, agent1, agent2);
                        }
                    }
                });
            });
        }

        function handleSpecificCollaboration(type1, type2, agent1, agent2) {
            // Define specific collaboration patterns
            const collaborationMap = {
                'analyzer-explorer': () => {
                    agent2.noveltyScore += 0.3; // Explorer gains from systematic insights
                    logEntry('Analyzer provides structured framework for Explorer\'s creativity', 'emergence');
                },
                'synthesizer-analyzer': () => {
                    agent1.collaborationScore += 0.2;
                    logEntry('Synthesizer integrates Analyzer\'s systematic findings', 'emergence');
                },
                'validator-synthesizer': () => {
                    agent2.confidence += 0.1;
                    agent1.confidence += 0.1;
                    logEntry('Validator confirms Synthesizer\'s integrated insights', 'emergence');
                },
                'explorer-validator': () => {
                    if (agent1.noveltyScore > 2.0 && agent2.confidence > 0.7) {
                        logEntry('BREAKTHROUGH: Creative solution validated!', 'emergence');
                    }
                }
            };

            const key = `${type1}-${type2}`;
            const reverseKey = `${type2}-${type1}`;

            if (collaborationMap[key]) {
                collaborationMap[key]();
            } else if (collaborationMap[reverseKey]) {
                collaborationMap[reverseKey]();
            }
        }

        function detectEmergence() {
            // Advanced emergence detection with learning integration
            const activeAgents = Object.keys(agents).filter(key => agents[key].active);

            if (activeAgents.length >= 2) {
                const analyzer = agents.analyzer;
                const synthesizer = agents.synthesizer;
                const explorer = agents.explorer;
                const validator = agents.validator;

                let emergenceDetected = false;

                // Pattern 1: Creative-Systematic Synergy
                if (synthesizer.active && synthesizer.collaborationScore > 30 &&
                    explorer.active && explorer.noveltyScore > 0.7) {
                    logEntry('âœ¨ EMERGENCE: Creative-systematic breakthrough!', 'emergence');
                    learningEngine.recordSuccess(agents, { type: 'creative-systematic', strength: 'high' });
                    emergenceDetected = true;
                    synthesizer.collaborationScore *= 0.7; // Gradual reset
                }

                // Pattern 2: Validated Knowledge Construction
                if (validator.active && validator.confidence > 0.8 &&
                    analyzer.active && analyzer.memory.length > 8) {
                    logEntry('ðŸ”¬ EMERGENCE: Validated knowledge system formed!', 'emergence');
                    learningEngine.recordSuccess(agents, { type: 'knowledge-validation', strength: 'medium' });
                    emergenceDetected = true;
                }

                // Pattern 3: Collective Intelligence Convergence
                const proximityMatrix = calculateProximityMatrix(activeAgents);
                const avgProximity = proximityMatrix.reduce((a, b) => a + b, 0) / proximityMatrix.length;

                if (avgProximity < 100 && activeAgents.length >= 3) {
                    const collectiveIntelligence = calculateCollectiveIntelligence();
                    if (collectiveIntelligence > 0.75) {
                        logEntry('ðŸ§  EMERGENCE: Collective intelligence threshold reached!', 'emergence');
                        learningEngine.recordSuccess(agents, { type: 'collective-intelligence', strength: 'high' });
                        emergenceDetected = true;
                    }
                }

                // Pattern 4: Dynamic Adaptation Cascade
                if (analyzer.behaviorState === 'scanning' && explorer.behaviorState === 'exploring' &&
                    synthesizer.behaviorState === 'connecting') {
                    logEntry('ðŸŒŠ EMERGENCE: Dynamic adaptation cascade initiated!', 'emergence');
                    learningEngine.recordSuccess(agents, { type: 'adaptation-cascade', strength: 'medium' });
                    emergenceDetected = true;
                }

                // Apply learning adaptations and meta-reflection periodically
                if (Math.random() < 0.1) { // 10% chance per cycle
                    learningEngine.adaptBehaviors(agents);
                }

                // Meta-reflection occurs less frequently but provides deeper insights
                if (Math.random() < 0.03) { // 3% chance per cycle
                    learningEngine.performMetaReflection();
                }

                // Meta-emergence: Detecting unexpected patterns
                if (emergenceDetected && learningEngine.successfulPatterns.size > 3) {
                    const patternDiversity = calculatePatternDiversity();
                    if (patternDiversity > 0.8) {
                        logEntry('ðŸš€ META-EMERGENCE: System discovering novel collaboration patterns!', 'meta-emergence');
                    }
                }
            }
        }

        function calculateProximityMatrix(activeAgents) {
            const distances = [];
            for (let i = 0; i < activeAgents.length; i++) {
                for (let j = i + 1; j < activeAgents.length; j++) {
                    const dist = Math.sqrt(
                        Math.pow(agents[activeAgents[i]].x - agents[activeAgents[j]].x, 2) +
                        Math.pow(agents[activeAgents[i]].y - agents[activeAgents[j]].y, 2)
                    );
                    distances.push(dist);
                }
            }
            return distances;
        }

        function calculateCollectiveIntelligence() {
            const weights = {
                analyzer: agents.analyzer.active ? agents.analyzer.memory.length / 20 : 0,
                synthesizer: agents.synthesizer.active ? agents.synthesizer.collaborationScore / 50 : 0,
                explorer: agents.explorer.active ? agents.explorer.noveltyScore : 0,
                validator: agents.validator.active ? agents.validator.confidence : 0
            };

            const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
            return Math.min(totalWeight / 4, 1.0); // Normalize to 0-1
        }

        function calculatePatternDiversity() {
            const patterns = Array.from(learningEngine.successfulPatterns.keys());
            const uniqueContexts = new Set();

            patterns.forEach(pattern => {
                const parsed = JSON.parse(pattern);
                uniqueContexts.add(parsed.context_type);
            });

            return uniqueContexts.size / Math.max(patterns.length, 1);
        }

        function updateAnalyticsDashboard() {
            // Update Analyzer metrics
            if (agents.analyzer.active) {
                document.getElementById('analyzerMemory').textContent = agents.analyzer.memory.length;
                document.getElementById('analyzerRadius').textContent = agents.analyzer.scanRadius;
                const coverage = Math.min((agents.analyzer.memory.length / 50) * 100, 100);
                document.getElementById('analyzerCoverage').textContent = coverage.toFixed(1) + '%';
                document.getElementById('analyzerGauge').style.setProperty('--gauge-width', coverage + '%');
            }

            // Update Synthesizer metrics
            if (agents.synthesizer.active) {
                document.getElementById('synthesizerScore').textContent = agents.synthesizer.collaborationScore.toFixed(1);
                document.getElementById('synthesizerConnections').textContent = agents.synthesizer.connections.length;
                const integrationIndex = Math.min(agents.synthesizer.collaborationScore / 5, 1);
                document.getElementById('synthesizerIntegration').textContent = integrationIndex.toFixed(2);
                document.getElementById('synthesizerGauge').style.setProperty('--gauge-width', (integrationIndex * 100) + '%');
            }

            // Update Explorer metrics
            if (agents.explorer.active) {
                document.getElementById('explorerNovelty').textContent = agents.explorer.noveltyScore.toFixed(2);
                document.getElementById('explorerCreativity').textContent = agents.explorer.creativityBoost.toFixed(1);
                document.getElementById('explorerAttempts').textContent = agents.explorer.attempts.length;
                const noveltyPercent = Math.min((agents.explorer.noveltyScore / 5) * 100, 100);
                document.getElementById('explorerGauge').style.setProperty('--gauge-width', noveltyPercent + '%');
            }

            // Update Validator metrics
            if (agents.validator.active) {
                const confidencePercent = (agents.validator.confidence * 100);
                document.getElementById('validatorConfidence').textContent = confidencePercent.toFixed(0) + '%';
                document.getElementById('validatorErrors').textContent = agents.validator.errorCount;
                const accuracy = Math.max(100 - (agents.validator.errorCount * 10), 0);
                document.getElementById('validatorAccuracy').textContent = accuracy.toFixed(0) + '%';
                document.getElementById('validatorGauge').style.setProperty('--gauge-width', confidencePercent + '%');
            }
        }

        // Challenge Designer Functions
        function toggleChallengeDesigner() {
            const designer = document.getElementById('challengeDesigner');
            designer.style.display = designer.style.display === 'none' ? 'block' : 'none';
        }

        function generateChallenge() {
            const type = document.getElementById('challengeTypeSelect').value;
            const difficulty = parseInt(document.getElementById('difficultySlider').value);
            const collaboration = document.getElementById('collaborationSelect').value;

            // Clear existing obstacles and targets
            obstacles = [];

            // Generate challenge based on parameters
            switch(type) {
                case 'pathfinding':
                    generatePathfindingChallenge(difficulty);
                    break;
                case 'optimization':
                    generateOptimizationChallenge(difficulty);
                    break;
                case 'pattern-recognition':
                    generatePatternChallenge(difficulty);
                    break;
                case 'creative-synthesis':
                    generateCreativeChallenge(difficulty);
                    break;
                case 'multi-objective':
                    generateMultiObjectiveChallenge(difficulty);
                    break;
            }

            applyCollaborationRequirement(collaboration);
            currentChallenge = `${type} (difficulty: ${difficulty}, collaboration: ${collaboration})`;
            logEntry(`Generated custom challenge: ${currentChallenge}`, 'system');
        }

        function generatePathfindingChallenge(difficulty) {
            // Create obstacles based on difficulty
            const numObstacles = difficulty * 2 + 1;
            for (let i = 0; i < numObstacles; i++) {
                obstacles.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: Math.random() * (canvas.height - 100) + 50,
                    width: 40 + Math.random() * 60,
                    height: 40 + Math.random() * 60
                });
            }

            // Position target in challenging location
            challengeTarget = {
                x: canvas.width - 80,
                y: canvas.height - 80
            };
        }

        function generateOptimizationChallenge(difficulty) {
            // Create multiple targets that require optimization
            obstacles = [];
            for (let i = 0; i < difficulty; i++) {
                obstacles.push({
                    x: (i + 1) * (canvas.width / (difficulty + 1)) - 25,
                    y: 200 + Math.sin(i) * 100,
                    width: 50,
                    height: 50,
                    isTarget: true
                });
            }
            challengeTarget = { x: canvas.width/2, y: canvas.height/2 };
        }

        function generatePatternChallenge(difficulty) {
            // Create geometric patterns that need recognition
            obstacles = [];
            const pattern = difficulty % 3; // 0=circle, 1=spiral, 2=fractal

            if (pattern === 0) {
                // Circular pattern
                for (let i = 0; i < difficulty * 4; i++) {
                    const angle = (i / (difficulty * 4)) * Math.PI * 2;
                    const radius = 150;
                    obstacles.push({
                        x: canvas.width/2 + Math.cos(angle) * radius - 15,
                        y: canvas.height/2 + Math.sin(angle) * radius - 15,
                        width: 30,
                        height: 30
                    });
                }
            }
            challengeTarget = { x: canvas.width/2, y: canvas.height/2 };
        }

        function generateCreativeChallenge(difficulty) {
            // Asymmetric, unconventional layouts
            obstacles = [];
            for (let i = 0; i < difficulty * 3; i++) {
                obstacles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    width: 10 + Math.random() * 100,
                    height: 10 + Math.random() * 100
                });
            }

            // Multiple targets requiring creative synthesis
            challengeTarget = {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height
            };
        }

        function generateMultiObjectiveChallenge(difficulty) {
            // Complex challenge requiring all agent types
            obstacles = [];

            // Systematic section (Analyzer territory)
            for (let i = 0; i < 3; i++) {
                obstacles.push({
                    x: i * 80 + 50,
                    y: 50,
                    width: 60,
                    height: 100
                });
            }

            // Creative section (Explorer territory)
            for (let i = 0; i < difficulty; i++) {
                obstacles.push({
                    x: Math.random() * 200 + 400,
                    y: Math.random() * 200 + 200,
                    width: Math.random() * 80 + 20,
                    height: Math.random() * 80 + 20
                });
            }

            challengeTarget = { x: canvas.width - 50, y: canvas.height - 50 };
        }

        function applyCollaborationRequirement(requirement) {
            switch(requirement) {
                case 'required':
                    // Make challenge impossible without collaboration
                    logEntry('Challenge requires mandatory collaboration for success', 'system');
                    break;
                case 'specialized':
                    // Assign specific roles to specific agents
                    logEntry('Challenge requires specialized agent roles', 'system');
                    break;
                case 'recommended':
                    // Optimize for collaboration but allow solo approaches
                    logEntry('Challenge optimized for collaborative approaches', 'system');
                    break;
            }
        }

        function addObstacle() {
            obstacles.push({
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * (canvas.height - 100) + 50,
                width: 60,
                height: 60
            });
            logEntry('Manual obstacle added', 'system');
        }

        function clearObstacles() {
            obstacles = [];
            logEntry('All obstacles cleared', 'system');
        }

        function updateLearningDashboard() {
            // Update learning metrics
            document.getElementById('learnedPatterns').textContent = learningEngine.successfulPatterns.size;
            document.getElementById('adaptationCount').textContent = learningEngine.adaptationCounter;

            // Calculate and display pattern diversity
            const diversity = learningEngine.successfulPatterns.size > 0 ? calculatePatternDiversity() : 0;
            document.getElementById('patternDiversity').textContent = diversity.toFixed(2);

            // Update recent learning events (if we have any stored)
            if (learningEngine.recentEvents && learningEngine.recentEvents.length > 0) {
                const eventsContainer = document.getElementById('learningEvents');
                eventsContainer.innerHTML = learningEngine.recentEvents
                    .slice(-3) // Show last 3 events
                    .map(event => `<div class="learning-event">${event}</div>`)
                    .join('');
            }
        }

        // Enhance learning engine with event tracking
        learningEngine.recentEvents = [];
        learningEngine.logLearningEvent = function(event) {
            this.recentEvents.push(`${new Date().toLocaleTimeString()}: ${event}`);
            if (this.recentEvents.length > 10) {
                this.recentEvents.shift(); // Keep only recent events
            }
        };

        // Override the recordSuccess method to include event logging
        const originalRecordSuccess = learningEngine.recordSuccess;
        learningEngine.recordSuccess = function(agents, context) {
            originalRecordSuccess.call(this, agents, context);
            this.logLearningEvent(`Pattern learned: ${context.type} (${context.strength} strength)`);
        };

        // Override the adaptBehaviors method to include event logging
        const originalAdaptBehaviors = learningEngine.adaptBehaviors;
        learningEngine.adaptBehaviors = function(agents) {
            const sizeBefore = this.adaptationCounter;
            originalAdaptBehaviors.call(this, agents);
            if (this.adaptationCounter > sizeBefore) {
                this.logLearningEvent(`Behaviors adapted based on learned patterns`);
            }
        };

        // Update slider display
        document.addEventListener('DOMContentLoaded', function() {
            const slider = document.getElementById('difficultySlider');
            const valueSpan = document.getElementById('difficultyValue');

            slider.addEventListener('input', function() {
                valueSpan.textContent = slider.value;
            });
        });

        // Initialize
        logEntry('Interactive Collaboration Simulator initialized by Alice & Bob', 'system');
        logEntry('ðŸ§  Advanced Learning Engine: ACTIVE', 'learning');
        logEntry('Ready to explore emergence through adaptive AI collaboration', 'system');
    </script>
</body>
</html>